# HTTP入门

## 1. 为什么学习HTTP

我们绝大多数的Web应用都是基于HTTP来进行开发的。我们对Web的操作都是通过HTTP协议来进行传输数据的。

HTTP的诞生主要是为了能够**让文档之间相互关联，形成超文本可以互相传阅**

可以说，Http就是Web通信的基础，这是我们必学的。

## 2. HTTP基础概念

我们学计算机网络的时候就知道，我们把计算机网络分层了5层，一般我们现在用的都是TCP/IP这么一个分层结构。

**计算机网络五层架构**

|  原理性分层  |             相关协议             |
| :----------: | :------------------------------: |
|   5.应用层   | HTTP，DNS，SMTP，IMAP，FTP，DHCP |
|   4.传输层   |             TCP,UDP              |
|   3.网络层   |         IP,ARP,ICMP,NAT          |
| 2.数据链路层 |                                  |
|   1.物理层   |                                  |

首先，我们先得知道，为什么我们要在计算机网络中分层次？

因为如果两台计算机能够相互通信的话，实际实现起来是非常困难操作的…我们**分层的目的就是为了将困难的问题简单化**，并且如果我们分层了，我们在使用的时候就可**以仅仅关注我们需要关注的层次，而不用理会其他层**。

如果需要改动设计的时候，我们只需要把变动的层替换即可，并不用涉及到其他的层次。

这与我们程序设计中的`低耦合`是一个概念。

**而我们的HTTP协议是在最上层，也就是应用层**。这是最贴近我们的程序员的层次。

## 3. 网站通信粗略过程

我们知道HTTP是在应用层中的，显然，**我们在Web通信的过程中，不仅仅是需要HTTP协议的，还会涉及到其他的协议的**。

**`DNS`：负责解析域名**

- 我们访问一个网页的时候，往往是通过域名来访问的`www.lzw.today`,而计算机通信只认的是我们的主机地址(192.168.xxx.xxx)，因此，当我们输入域名的时候，需要DNS把域名解析成主机来进行访问。

**`HTTP`：产生请求报文数据**

- 当我们对Web页面进行操作的时候，就会产生HTTP报文数据，请求对应的服务端进行响应。

**`TCP协议`：分割HTTP数据，保证数据运输**

- TCP协议**采用了三次握手的方式来保证数据的准确运输**，在运输的数据的时候，发送标识过去给服务器，服务器也返回标识给客户端，而客户端收到消息后再次返回标识给服务器。这样一来就保证了数据运输是可靠的。

**`IP协议`：传输数据包，找到通信目的地地址。**

- IP协议把我们的产生的数据包发送给对方，IP地址指明了节点被分配的地址，但IP地址可能会变换，**我们可以使用ARP协议来将IP地址反射为MAC地址**。MAC地址是不会更改的，是网卡所属的固定地址。
- 在找到通信目的地之前，**我们是需要不断的中转的，这过程我们称作为：“路由中转”**，我们并不知道路由中转了多少次的。因此是不能全面了解到互联网中的传输状况的。

## 4. 告知服务器请求的意图

我们如果开发过Web程序的话，我们知道常用的提交方式有POST和GET方法

GET是用来获取数据的，POST是用来提交数据的。

**HTTP提供方法的目的就是为了告知服务器该客户端想进行什么操作**。当HTTP是OPTIONS方法的时候，服务器端就会返回它支持什么HTTP方法。

当然了，**现在RESTful盛行，也就是充分利用了HTTP协议的这些方法**。

## 5. HTTP是不保存状态的协议

HTTP是无状态的，也就是说，**它是不对通信状态进行保存的。它并不知道之前通信的对方是谁**。这样设计的目的就是为了让HTTP简单化，能够快速处理大量的事务！

但是，我们经常是需要知道访问的人是谁，于是就有了Cookie技术了。

- 要是服务器端想要记住客户端是谁，那么就颁发一个cookie给客户端
- 客户端把Cookie保存在硬盘中，当下次访问服务器的时候，浏览器会自动把客户端的cookie带过去。
- 就这样，服务器就能够知道是谁了。

## 6. 持久连接

在HTTP1.0的时候，每一次进行HTTP通信就会断开一次连接。如果容量很少的文本传输是没有问题的。但是如果我们访问一个网页，该网页有非常多的图片。一个图片就算上一个HTTP请求了。那么在中途中就不断地建立TCP连接、获取图片、断开TCP连接。

这样是非常浪费资源的，因此在HTTP1.1版本，就是持久连接了。**一次HTTP连接能够处理多个请求**。

持久连接为“管线化”方式发送成为了可能：**在一次HTTP连接里面，不需要等待服务器响应请求，就能够继续发送第二次请求**。

## 7. 提升传输效率

在说明之前，首先我们要知道什么是`实体主体`

- **`实体主体`就是作为数据在HTTP中传输的数据**。

一般地，**`实体主体`可以等价为`报文主体`，报文主体是`HTTP`中的一部分**

我们如果不使用任何手段，服务器返回的数据实体主体是原样返回的。我们可以使用两种方式来提高传输效率

- **使用`压缩技术`把实体主体压小，在客户端再把数据解析**
- **使用`块传输编码`，将实体主体分块传输，当浏览器解析到实体主体就能够显示了。**

我们如果在下载东西的过程中断了，按照以前我们是需要重新下载的，但是现在可以在中断中继续下载。我们可以**使用到获取范围数据，这种叫做范围请求**！

这种请求只会下载资源的一部分。

- 比如我的图片下载到一半了，我们只需要下载另一半就可以组成一张完整的图片了。那么**请求的时候请求没有下载的一部分即可。**

## 8. 常用的状态码简述

### 2XX

一般是`请求成功`

200 正常处理

204 成功处理，但服务器没有新数据返回，显示页面不更新

206 对服务器进行范围请求，只返回一部分数据

### 3XX

一般表示`重定向`

301 请求的资源已分配了新的URI中，URL地址改变了。【永久重定向】

302 请求的资源临时分配了新的URI中，URL地址没变【临时重定向】

303 与302相同的功能，但明确客户端应该采用GET方式来获取资源

304 发送了附带请求，但不符合条件【返回未过期的缓存数据】

307 与302相同，但不会把POST请求变成GET

### 4XX

表示`客户端出错了`。

400 请求报文语法错误了

401 需要认证身份

403 没有权限访问

404 服务器没有这个资源

### 5XX

`服务器出错了`

500 内部资源出错了

503 服务器正忙

## 9. 服务器与客户端之间的应用程序

首先要说的是，一个HTTP服务器可以拥有多个站点，也就是说：**HTTP下可以配置多个虚拟主机。当用户访问不同主机的时候，实际上都是访问同一台HTTP服务器。**

在客户端和服务器中还有一些用于**通信数据转发的应用程序**：

- 代理
  - 可以用来缓存数据，当代理缓存了数据以后，客户端就可以直接用代理获取数据
  - 可以用来对网站进行访问控制，获取访问日志记录
- 网关
  - 能够提供非HTTP请求的操作，访问数据库什么的
- 隧道
  - 建立一条安全的通信路径，可以使用SSL等加密手段进行通信。

## 10. HTTP首部简述

### 10.1 HTTP请求报文

HTTP请求报文：在请求中，HTTP报文由方法、URI、HTTP版本、HTTP首部字段等部分组成。

![1616ac768892bd66 (1)](https://gitee.com/lzw657434763/pictures/raw/master/Blog/1616ac768892bd66%20(1).jpg)

1. `请求行`【描述客户端的**请求方式**、**请求的资源名称**，以及使用的**HTTP协议版本号**】
2. `首部字段`【描述客户端请求哪台主机，以及**客户端的一些环境信息**等】
3. 一个空行

**首部字段例子：**

- Accept: text/html,image/*    【浏览器告诉服务器，它支持的数据类型】
- Accept-Charset: ISO-8859-1	【浏览器告诉服务器，它支持哪种**字符集**】
- Accept-Encoding: gzip,compress 【浏览器告诉服务器，它支持的**压缩格式**】
- Accept-Language: en-us,zh-cn 【浏览器告诉服务器，它的语言环境】
- Host: 【浏览器告诉服务器，它的想访问哪台主机】
- If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，缓存数据的时间】
- Referer: 【浏览器告诉服务器，客户机是从那个页面来的---**反盗链**】
- 8.User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)【浏览器告诉服务器，浏览器的内核是什么】
- Cookie【浏览器告诉服务器，**带来的Cookie是什么**】
- Connection: close/Keep-Alive  【浏览器告诉服务器，请求完后是断开链接还是保持链接】 
- Date: Tue, 11 Jul 2000 18:23:51 GMT【浏览器告诉服务器，请求的时间】 

### 10.2 HTTP响应报文

HTTP响应报文：在响应中，HTTP报文由HTTP版本、状态码（数字和原因短语）、HTTP首部字段3部分组成。 

![2](https://gitee.com/lzw657434763/pictures/raw/master/Blog/2.jpg)

1. 一个`状态行`【用于描述**服务器对请求的处理结果。**】
2. `首部字段`【用于描述**服务器的基本信息**，以及**数据的描述**，**服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据**】
3. 一个空行
4. `实体内容`【**服务器向客户端回送的数据**】

> **状态行**

- 格式： HTTP版本号　状态码　原因叙述
- 状态行：HTTP/1.1  200    OK
- 状态码用于表示**服务器对请求的处理结果**，它是一个**三位的十进制数**。响应状态码分为5类

**首部字段例子：**

- Location: ‘     ’ 【服务器告诉浏览器**要跳转到哪个页面**】
- Server:apache tomcat【服务器告诉浏览器，服务器的型号是什么】
- Content-Encoding: gzip 【服务器告诉浏览器**数据压缩的格式**】
- Content-Length: 80 【服务器告诉浏览器回送数据的长度】
- Content-Language: zh-cn 【服务器告诉浏览器，服务器的语言环境】
- Content-Type: text/html; charset=GB2312 【服务器告诉浏览器，**回送数据的类型**】
- Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器该资源上次更新时间】
- Refresh: 1;url=‘        ’【服务器告诉浏览器要**定时刷新**】
- Content-Disposition: attachment; filename=aaa.zip【服务器告诉浏览器**以下载方式打开数据**】
- Transfer-Encoding: chunked  【服务器告诉浏览器数据以分块方式回送】
- Set-Cookie:SS=Q0=5Lb_nQ; path=/search【服务器告诉浏览器要**保存Cookie**】
- Expires: -1【服务器告诉浏览器**不要设置缓存**】
- Cache-Control: no-cache  【服务器告诉浏览器**不要设置缓存**】
- Pragma: no-cache   【服务器告诉浏览器**不要设置缓存**】
- Connection: close/Keep-Alive   【服务器告诉浏览器连接方式】
- Date: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器回送数据的时间】



## 11. HTTPS简述

HTTP在安全上是不足的

- 通信使用明文【没有加密过内容的】
- 不验证通信方身份，无论是客户端和服务器，都是随意通信的
- 无法证明报文的完整性【别人监听后，可以篡改】

我们最好就是**使用SSL建立安全的通信线路**，就可以在这条线路上进行HTTP通信了。

其实HTTPS就是披着SSL的HTTP...

HTTPS使用的是共享密钥和公开私有密钥混合来进行加密的。由于公开私有密钥需要太多的资源，不可能一直以公开私有密钥进行通信。因此，**HTTP在建立通信线路的时候使用公开私有密钥，当建立完连接后，随后就使用共享密钥进行加密和解密了**

对于认证方面，HTTPS是**基于第三方的认证机构来获取认受认可的证书**、因此，可以从中认证该服务器是否是合法的。

而客户端方面则需要自己购买认证证书、这实施起来难度是很大的【认证证书需要钱】。

所以，一般的网站都是使用表单认证就算了，这是用得最广泛的客户端认证了。

### 11.1 HTTPS基础

- 对称加密：

- - 加密和解密都是用同一个密钥

- 非对称加密：

- - 加密用公开的密钥，解密用私钥
  - (私钥只有自己知道，公开的密钥大家都知道)

- 数字签名：

- - 验证传输的内容**是对方发送的数据**
  - 发送的数据**没有被篡改过**

- 数字证书（Certificate Authority）简称CA

- - 认证机构证明是**真实的服务器发送的数据**。



# 总结

## HTTP

**HTTP协议是客户端和服务器交互的一种通讯的格式**

我们会学到`Request Method`这个字段，现在盛行的`RESTful`就是**充分利用**这个字段的「含义」

- GET：请求资源
- POST：创建资源
- PUT：更新资源
- DELETE：删除资源

## HTTP各个版本的特点

`HTTP1.0`默认是短连接，每次与服务器交互，都需要新开一个连接。

`HTTP1.1`版本：

- 最主要的是**默认持久连接**。只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求。
- 其次就是**断点续传**（Chunked transfer-coding）。利用HTTP消息头使用分块传输编码，将实体主体分块传输。

`HTTP/2`版本：

- 在`HTTP1.1`提出了管线化(pipelining)理论，但是默认都是关闭的。而`HTTP/2`允许同时通过单一的TCP连接发起**多个的请求和响应消息**
- 不再以文本的方式传输，采用**二进制分帧层**，对头部进行了压缩，支持流的控制

`HTTP/3`版本：

- `HTTP1.x`和`HTTP/2`底层都是TCP，而`HTTP/3`底层是UDP。使用`HTTP/3`能够减少**RTT「往返时延」**（TCP三次握手，TLS握手）

## HTTPS

HTTP协议默认是「明文」的，那就是说，如果在交互的过程中被「挟持」了，那传输的信息会「**暴露**」或者「**篡改**」



1. 首先客户端跟服务器之间的交互，客户端需要知道服务端是不是真实的。因为客户端与服务端之间的通讯都有可能被「挟持」。所以需要有一个公信机构CA来让客户端知道服务端是真实的。
2. CA机构将服务端的公钥信息用自己的私钥加密，客户端用CA机构的公钥解密。保证CA证书是没有被篡改，是真实的。
3. 客户端拿到CA证书，就能解析到服务端的公钥。客户端生成一个Key作为对称加密的秘钥，用服务端的公钥加密传给服务端。
4. 服务端用自己的私钥解密客户端的数据，得到对称加密的秘钥。
5. 后续就可以通过对称加密的秘钥愉快发送/接收消息了。







