# 1. Filter 过滤器

用来过滤网站的数据

- 处理中文乱码
- 登录验证

![image-20201125132719735](https://gitee.com/lzw657434763/pictures/raw/master/Blog/image-20201125132719735.png)



Filter开发步骤：

1. 导包
2. 编写过滤器

实现Filter接口，重写对应的方法

```java
public class CharacterEncodingFilter implements javax.servlet.Filter {
    //初始化
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("CharacterEncodingFilter初始化了");
    }
        /*
        1. 过滤中的所有代码，在过滤特定请求的时候都会执行
        2. 必须要让过滤器继续同行
        chain.doFilter(request,response);
        */
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        servletRequest.setCharacterEncoding("utf-8");
        servletResponse.setCharacterEncoding("utf-8");
        servletResponse.setContentType("text/hrml;charset=utf-8");

        System.out.println("CharacterEncodingFilter执行前。。。");
        //让我们的请求继续走，如果不写，程序到这里就停止了
        filterChain.doFilter(servletRequest,servletResponse);
        System.out.println("CharacterEncodingFilter执行后。。。");
    }
    //销毁 web服务器关闭的时候，过滤会销毁
    public void destroy() {
        System.out.println("CharacterEncodingFilter销毁了");
    }
}
```

3.  在web.xml中配置 Filter

```xml
<filter>
    <filter-name>CharacterEncodingFilter</filter-name>
    <filter-class>com.Lee.filter.CharacterEncodingFilter</filter-class>
</filter>
<filter-mapping>
    <filter-name>CharacterEncodingFilter</filter-name>
    <!--过滤servlet下的所有请求-->
    <url-pattern>/servlet/*</url-pattern>
</filter-mapping>
```

# 2. 监听器

实现一个监听器的接口；（有N种）
1. 编写一个监听器
   实现监听器的接口…

```java

public class OnlineCountListener implements HttpSessionListener {
    //创建session监听:看你的一举一动
    //一旦创建一个session，就会触发一个事件
    public void sessionCreated(HttpSessionEvent se) {
        ServletContext ctx =se.getSession().getServletContext();
        Integer onlieCount = (Integer) ctx.getAttribute("onlieCount");

        if(onlieCount==null){
            onlieCount = new Integer(1);
        }else{
            int count = onlieCount.intValue();
            onlieCount = new Integer(count+1);
        }

        ctx.setAttribute("onlieCount",onlieCount);
    }
    //销毁session监听
    //一旦session销毁，就会触发一个事件
    public void sessionDestroyed(HttpSessionEvent se) {
        ServletContext ctx =se.getSession().getServletContext();
        Integer onlieCount = (Integer) ctx.getAttribute("onlieCount");

        if(onlieCount==null){
            onlieCount = new Integer(1);
        }else{
            int count = onlieCount.intValue();
            onlieCount = new Integer(count-1);
        }

        ctx.setAttribute("onlieCount",onlieCount);
    }
}
```

2. web.xml中注册监听器

```xml
<!--注册监听器-->
<listener>
    <listener-class>com.Lee.listener.OnlineCountListener</listener-class>
</listener>
```



# 3. 过滤器，监听器常见应用

监听器：GUI界面经常使用

```java
public class TestPanel {
    public static void main(String[] args) {
        Frame frame = new Frame("你好");//新建一个窗体
        Panel panel = new Panel(null);//面板
        frame.setLayout(null);//设置窗体的布局
        frame.setBounds(300,300,500,500);
        frame.setBackground(new Color(0,0,255));
        panel.setBounds(50,50,300,300);
        panel.setBackground(new Color(0x00FF00));
        frame.add(panel);
        frame.setVisible(true);

        //监听事件，监听关闭事件
        frame.addWindowListener(new WindowAdapter() {
            @Override
            public void windowClosing(WindowEvent e) {
                System.out.println("关闭了");
                System.exit(0);
            }
        });


    }
}
```



> 用户登录之后才能进入主页











































